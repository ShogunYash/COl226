(* Corrected SECD Machine Implementation in OCaml *)

(* Expressions *)
type expr =
  | Var of string
  | N of int
  | B of bool
  | Sub of expr * expr
  | Div of expr * expr
  | Rem of expr * expr
  | Add of expr * expr
  | Mult of expr * expr
  | GreaterT of expr * expr
  | GreaterTE of expr * expr
  | LessT of expr * expr
  | LessTE of expr * expr
  | Equals of expr * expr
  | Not of expr
  | Absolute of expr
  | Negative of expr
  | And of expr * expr
  | Or of expr * expr
  | IfThenElse of expr * expr * expr
  | Abs of string * expr          (* lambda abstraction *)
  | App of expr * expr            (* application *)

(* SECD opcodes *)
type op =
  | VAR of string
  | INTOP of int
  | BOOLOP of bool
  | FABSOP of string * op list
  | FCALLOP of op list * op list
  | APPOP
  | RETOP
  | IFTEOP of op list * op list
  | PLUSOP | MINUSOP | MULTOP | DIVOP | REMOP
  | GTOP | GEQOP | LTOP | LEQOP | EQUALSOP
  | NOTOP | ABSOLUTEOP | NEGATIVEOP
  | CONJOP | DISJOP

(* Runtime values *)
type value =
  | NumVal of int
  | BoolVal of bool
  | FuncVal of string * op list * table  (* closure: param, body code, env *)

and stack_token = VClose of value * table
and table = (string * stack_token) list

exception StackError of string
exception ValueError
exception OpError

let rec lookupTable x tbl =
  match tbl with
  | [] -> raise ValueError
  | (y, v) :: rest -> if x = y then v else lookupTable x rest

let augment tbl x v =
  let rec aux acc = function
    | [] -> List.rev ((x, v) :: acc)
    | (y, w) :: rest when y = x -> List.rev_append acc ((x, v) :: rest)
    | pair :: rest -> aux (pair :: acc) rest
  in aux [] tbl

(* Compiler *)
let rec compile e =
  match e with
  | Var x -> [VAR x]
  | N n -> [INTOP n]
  | B b -> [BOOLOP b]
  | Sub (a,b) -> compile a @ compile b @ [MINUSOP]
  | Div (a,b) -> compile a @ compile b @ [DIVOP]
  | Rem (a,b) -> compile a @ compile b @ [REMOP]
  | Add (a,b) -> compile a @ compile b @ [PLUSOP]
  | Mult (a,b) -> compile a @ compile b @ [MULTOP]
  | GreaterT (a,b) -> compile a @ compile b @ [GTOP]
  | GreaterTE(a,b) -> compile a @ compile b @ [GEQOP]
  | LessT   (a,b) -> compile a @ compile b @ [LTOP]
  | LessTE  (a,b) -> compile a @ compile b @ [LEQOP]
  | Equals  (a,b) -> compile a @ compile b @ [EQUALSOP]
  | Not e1 -> compile e1 @ [NOTOP]
  | Absolute e1 -> compile e1 @ [ABSOLUTEOP]
  | Negative e1 -> compile e1 @ [NEGATIVEOP]
  | And (a,b) -> compile a @ compile b @ [CONJOP]
  | Or  (a,b) -> compile a @ compile b @ [DISJOP]
  | IfThenElse(c,t,e2) -> compile c @ [IFTEOP(compile t, compile e2)]
  | Abs(x,body) -> [FABSOP(x, compile body @ [RETOP])]
  | App(f,a) -> [FCALLOP(compile f, compile a)]

(* SECD interpreter *)
let rec secd stack env code dump =
  match code with
  | [] -> (
      match stack with
      | VClose(v,_) :: [] -> v
      | _ -> raise (StackError "Expected single value on stack at end")
    )
  | op :: rest ->
    (match op with
     | INTOP n -> secd (VClose(NumVal n, env)::stack) env rest dump
     | BOOLOP b -> secd (VClose(BoolVal b, env)::stack) env rest dump
     | VAR x ->
         let VClose(v, tbl') = lookupTable x env in
         let tbl'' = augment tbl' x (VClose(v,tbl')) in
         let env' = augment env x (VClose(v,tbl')) in
         secd (VClose(v, tbl'')::stack) env' rest dump
     | PLUSOP ->
         (match stack with
          | VClose(NumVal n2,_) :: VClose(NumVal n1,_) :: tl ->
              secd (VClose(NumVal(n1+n2),env)::tl) env rest dump
          | _ -> raise (StackError "PLUS expects two ints"))
     | MINUSOP ->
         (match stack with
          | VClose(NumVal n2,_) :: VClose(NumVal n1,_) :: tl ->
              secd (VClose(NumVal(n1-n2),env)::tl) env rest dump
          | _ -> raise (StackError "MINUS expects two ints"))
     | MULTOP ->
         (match stack with
          | VClose(NumVal n2,_) :: VClose(NumVal n1,_) :: tl ->
              secd (VClose(NumVal(n1*n2),env)::tl) env rest dump
          | _ -> raise (StackError "MULT expects two ints"))
     | DIVOP ->
         (match stack with
          | VClose(NumVal n2,_) :: VClose(NumVal n1,_) :: tl when n2<>0 ->
              secd (VClose(NumVal(n1/n2),env)::tl) env rest dump
          | _ -> raise (StackError "DIV expects two ints and non-zero divisor"))
     | REMOP ->
         (match stack with
          | VClose(NumVal n2,_) :: VClose(NumVal n1,_) :: tl when n2<>0 ->
              secd (VClose(NumVal(n1 mod n2),env)::tl) env rest dump
          | _ -> raise (StackError "REM expects two ints and non-zero divisor"))
     | NOTOP ->
         (match stack with
          | VClose(BoolVal b,_) :: tl -> secd (VClose(BoolVal(not b),env)::tl) env rest dump
          | _ -> raise (StackError "NOT expects a bool"))
     | ABSOLUTEOP ->
         (match stack with
          | VClose(NumVal n,_) :: tl -> secd (VClose(NumVal(abs n),env)::tl) env rest dump
          | _ -> raise (StackError "ABS expects an int"))
     | NEGATIVEOP ->
         (match stack with
          | VClose(NumVal n,_) :: tl -> secd (VClose(NumVal(-n),env)::tl) env rest dump
          | _ -> raise (StackError "NEG expects an int"))
     | CONJOP ->
         (match stack with
          | VClose(BoolVal b2,_) :: VClose(BoolVal b1,_) :: tl ->
              secd (VClose(BoolVal(b1 && b2),env)::tl) env rest dump
          | _ -> raise (StackError "AND expects two bools"))
     | DISJOP ->
         (match stack with
          | VClose(BoolVal b2,_) :: VClose(BoolVal b1,_) :: tl ->
              secd (VClose(BoolVal(b1 || b2),env)::tl) env rest dump
          | _ -> raise (StackError "OR expects two bools"))
     | GTOP ->
         (match stack with
          | VClose(NumVal n2,_) :: VClose(NumVal n1,_) :: tl ->
              secd (VClose(BoolVal(n1>n2),env)::tl) env rest dump
          | _ -> raise (StackError "GT expects two ints"))
     | GEQOP ->
         (match stack with
          | VClose(NumVal n2,_) :: VClose(NumVal n1,_) :: tl ->
              secd (VClose(BoolVal(n1>=n2),env)::tl) env rest dump
          | _ -> raise (StackError "GEQ expects two ints"))
     | LTOP ->
         (match stack with
          | VClose(NumVal n2,_) :: VClose(NumVal n1,_) :: tl ->
              secd (VClose(BoolVal(n1<n2),env)::tl) env rest dump
          | _ -> raise (StackError "LT expects two ints"))
     | LEQOP ->
         (match stack with
          | VClose(NumVal n2,_) :: VClose(NumVal n1,_) :: tl ->
              secd (VClose(BoolVal(n1<=n2),env)::tl) env rest dump
          | _ -> raise (StackError "LEQ expects two ints"))
     | EQUALSOP ->
         (match stack with
          | VClose(NumVal n2,_) :: VClose(NumVal n1,_) :: tl ->
              secd (VClose(BoolVal(n1=n2),env)::tl) env rest dump
          | _ -> raise (StackError "EQUALS expects two ints"))
     | IFTEOP(c1,c2) ->
         (match stack with
          | VClose(BoolVal b,_) :: tl ->
              let next = if b then c1 @ rest else c2 @ rest in
              secd tl env next dump
          | _ -> raise (StackError "IFTE expects a bool"))
     | FABSOP(x,body) ->
         secd (VClose(FuncVal(x,body,env),env)::stack) env rest dump
     | FCALLOP(cf,ca) ->
         secd stack env (cf @ ca @ [APPOP] @ rest) dump
     | APPOP ->
         (match stack with
          | VClose(v,_) :: VClose(FuncVal(x,body,env_clo),_) :: tl ->
              let env' = augment env_clo x (VClose(v,env_clo)) in
              secd [] env' body ((tl,env,rest)::dump)
          | _ -> raise (StackError "APP expects closure and argument"))
     | RETOP ->
         (match stack, dump with
          | VClose(v,_)::[], (s_old,e_old,c_old)::ds ->
              secd (VClose(v,e_old)::s_old) e_old c_old ds
          | _ -> raise (OpError)) )

(* Test harness *)
let run e =
  let code = compile e in
  let result = secd [] [] code [] in
  match result with
  | NumVal n -> Printf.printf "%d\n" n
  | BoolVal b -> Printf.printf "%b\n" b
  | FuncVal _ -> Printf.printf "<fun>\n"

(* Sample tests *)
let () =
  run (App(Abs("x", Var "x"), N 5));         (* => 5 *)
  run (App(App(Abs("x", Abs("y", Var "x")), B true), B false));  (* => true *)
  run (IfThenElse(GreaterT(N 3,N 2), N 10, N 20)); (* => 10 *)
  run (Add(N 2, Mult(N 3, N 4)));                (* => 14 *)
  run (App(Abs("x", Add(Var "x", N 1)), N 41)); (* => 42 *)

(* Fibonacci via Y combinator *)
let ycomb =
  Abs("f",
    App(
      Abs("x", App(Var "f", App(Var "x", Var "x"))),
      Abs("x", App(Var "f", App(Var "x", Var "x")))
    )
  );

let fib_fun =
  Abs("f", Abs("n",
    IfThenElse(
      Equals(Var "n", N 0), N 0,
      IfThenElse(
        Equals(Var "n", N 1), N 1,
        Add(
          App(Var "f", Sub(Var "n", N 1)),
          App(Var "f", Sub(Var "n", N 2))
        )
      )
    )
  ));

let fib = App(ycomb, fib_fun);

let () =
  run (App(fib, N 10));  (* => 55 *)
